import math
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

class DataProcessing(object):
    '''
    This class contains functions that help general processing
    '''

    def dotproduct(self, v1, v2):
        '''
        Input vectors: v1, v2
        Output: dot product of 2 vectors
        '''
        return sum((a*b) for a, b in zip(v1, v2))

    def length(self, v):
        '''
        Input: vector v
        Output: lenght of the vector v
        '''
        return math.sqrt(self.dotproduct(v, v))

    def angle(self, v1, v2):
        '''
        Input vectors: v1, v2
        Output: Angle between v1 and v2
        '''
        return np.rad2deg(math.acos(self.dotproduct(v1, v2) / (self.length(v1) * self.length(v2))))

    def plot_two_signals(self, setpoint, control_signal, time, angle_name, action, participant, label_1, label_2):
        '''
        Input: 2 signals
        Output: save/plot the signals in a single graph
        '''
        #Change the Size of Graph using Figsize
        fig = plt.figure(figsize = (20, 7))
        plt.rcParams['font.size'] = '20'

        #plot 
        plt.plot(time, setpoint, 'b-', linewidth = 2, label = label_1)
        plt.plot(time, control_signal, 'r-', linewidth = 2, label = label_2)
        
        # Labels' name
        plt.xlabel('Frames', fontsize=30)  
        plt.ylabel('Angle [deg]',  fontsize=30)
        
        # Set a title 
        name = angle_name + action.capitalize() + " - User " + str(participant)
        path = "./csv/" + str(participant) + "/" + action + "/"
        plt.title(name, fontsize=30) #'CONTROL SIGNAL '

        # trun off/on axis
        plt.axis('on')
        plt.grid()
        plt.legend()
        #plt.show()
        plt.savefig(path + name + ".pdf")  
        #plt.plot('control.pdf')  
        
    def plot_one_signal(self, setpoint, time, angle_name, action, participant):
        '''
        Input: 1 signal
        Output: save/plot the signal
        '''
        #Change the Size of Graph using Figsize
        fig = plt.figure(figsize = (20, 7))
        plt.rcParams['font.size'] = '20'
        #plot 
        plt.plot(time, setpoint, 'b-', linewidth = 2)
        # Labels' name
        plt.xlabel('Frames', fontsize=30)  
        plt.ylabel('Angle [deg]',  fontsize=30)
        name = angle_name + action.capitalize() + " - User " + str(participant)
        path = "./csv/" + str(participant) + "/" + action + "/"
        # Set a title 
        plt.title(name,  fontsize=30) #'CONTROL SIGNAL '
        # trun off/on axis
        plt.axis('on')
        plt.grid()
        #plt.show()
        plt.savefig(path + name + ".pdf")  

    def read_csv_combined(self, df, action, joint):
        '''
        Input: 
        action -> action to be extracted 
        joint -> joint to be extracted
        df -> all data
        Output: 
        all_data -> vector af extracted data 
        timestamp -> vector af timestamp for the data
        '''
        timestamp = []
        all_data = []
        for i in range(len(df)):
            if action == df['action'][i]:
                timestamp.append(float(df['timestamp'][i]))
                data = df[joint][i]
                aux_data = ''.join([i for i in data if not (i=='[' or i==']' or i==',')])
                data = np.array(aux_data.split())
                all_data.append(data[0:3].astype(float))
        return all_data, timestamp


    def get_angles_from_vector(self, vec, flag):
        '''
        This function calculates the projection of the angles generated by the vector on the xz and yz planes.
        Input: 
        vec -> vector to be projected
        flag -> hand > shoulder - bool
        
        Output: 
        roll -> angle roll
        pitch -> angle pitch
        '''
        roll = abs(np.rad2deg(math.atan(vec[1]/vec[2])))
        if (vec[2] < 0 and vec[0] > 0 and vec[1] < 0)  or (vec[2] < 0 and vec[0] > 0 and vec[1] > 0):
            pitch = np.rad2deg(math.atan2(vec[0], vec[2])) - 270
        else:
            pitch = 90 + np.rad2deg(math.atan2(vec[0], vec[2]))  
        if flag:
            pitch = - pitch
        return roll, pitch

    def string_to_float(self, vec):
        '''
        This function transforms strings to floats from csv
        Input: 
        vec -> vector to be found
        
        Output: 
        data_final -> new vector + traslation from the camera to the base frame
        '''
        data_final = []
        traslation_vec = [0.094, 0, 0.5962]                                       #base to camera
        for i in vec:
            data_float = np.ones((3))
            data_float[0] = float(i[0]) + traslation_vec[0]
            data_float[1] = float(i[1]) + traslation_vec[1]
            data_float[2] = float(i[2]) + traslation_vec[2]
            data_final.append(data_float)
        return data_final

    def read_file(self, name):
        '''
        This function reads a csv file
        Input: 
        name -> name of the file
        '''
        df = pd.read_csv(name, on_bad_lines = 'skip')
        return df
        
    def angle_between_vectors(self, center_point, upper_point, low_point):  
        '''
        This function calculates the angle between 2 vectos given
        Input: 
        center_point -> vector of shareed points
        upper_point -> vector of upper points
        low_point -> vector of lower points

        Output: 
        angles_vec -> vector of all generated angles
        '''
        angles_vec = []
        for i in range(len(center_point)):
            vec_1 = upper_point[i] - center_point[i]
            vec_2 = low_point[i] - center_point[i]
            aux_angle = self.angle(vec_1, vec_2)
            angles_vec.append(aux_angle)
        return angles_vec

    def vector_projections(self, hand, elbow, shoulder):  
        '''
        This function calculates the projections of the vector shoulder 
        Input: 
        hand -> vector of points
        elbow -> vector of points
        shoulder -> vector of points

        Output: 
        shoulder_roll -> vector of all generated angles roll 
        shoulder_pitch -> vector of all generated angles pitch
        '''
        shoulder_roll = []
        shoulder_pitch = []
        for i in range(len(shoulder)):
            vec = elbow[i] - shoulder[i]
            flag = False
            if hand[i][2] > shoulder[i][2]:
                flag = True
            roll, pitch = self.get_angles_from_vector(vec, flag)
            shoulder_roll.append(roll)
            shoulder_pitch.append(pitch)
        return shoulder_roll, shoulder_pitch

    def from_skeleton_to_robot_angle(self, skeleton_angle, joint_name):
        '''
        This function calculates the equivalence between angles of the skeleton and angles of the robot
        Input:
        joint_name -> joint to be calculated
        skeleton_angle -> angle of skeleton to be calculated

        Output:
        robot_angle -> angle of robot
        '''
        robot_angle = []
        for i in skeleton_angle:
            robot_angle.append(self.transform_ranges(joint_name, i))
        return robot_angle

    def transform_ranges(self, angle_name, old_angle):  
        '''
        This function calculates the equivalence between angles of the skeleton and angles of the robot
        Vectors with 2 pos. min and max and angle taken from skeleton

        Input:
        angle_name -> joint to be calculated
        old_angle -> angle of skeleton to be calculated

        Output:
        new_angle -> angle of robot
        '''
        if angle_name == 'neck_pitch': 
            skeleton_limits = [-70 + 180, 85 + 180]
            robot_limits = [-15, 25] 
        elif  angle_name == 'neck_yaw':
            skeleton_limits = [90, -90] 
            robot_limits = [-60, -60]
        elif angle_name =='elbow_left': 
            skeleton_limits = [180 - 142.6, 180 - 4.3]   #or [180 - 4.3, 180 - 142.6]
            robot_limits = [-77, -8]
        elif angle_name =='elbow_right': 
            skeleton_limits = [180 - 142.6, 180 - 4.3]
            robot_limits = [-77, -8]
        elif angle_name == 'shoulder_right':
            skeleton_limits = [-140, 140]            #[-130, 130]  [-190 + 90, 60 + 90]
            robot_limits = [-120, 120] 
        elif angle_name == 'shoulder_left':
            skeleton_limits = [-140, 140]            #[-130, 130]  [-190 + 90, 60 + 90] 
            robot_limits = [120, -120]
        elif angle_name =='shoulder_roll':
            skeleton_limits = [0, 90]   
            robot_limits = [-80, -20]
        skeleton_range = (skeleton_limits[1] - skeleton_limits[0])
        if skeleton_range == 0:
            new_angle = robot_limits[0]
            
        else:
            if old_angle < min(skeleton_limits):
                old_angle = min(skeleton_limits)
            elif old_angle > max(skeleton_limits):
                old_angle = max(skeleton_limits)
            robot_range = robot_limits[1] - robot_limits[0]
            new_angle = (((old_angle - skeleton_limits[0]) * robot_range) / skeleton_range) + robot_limits[0]
        return new_angle

    def save_data_for_qt(self, vec, name):
        '''
        This function saves all the angle data to be executed by QTrobot
        '''
        np.savetxt(name, vec)

    def get_positions_of_joints(self, df, action):
        '''
        This function reads all the points of the skeleton data according to the joint name
        Returns lists of all the joints
        '''

        joints_names = ['JOINT_HEAD','JOINT_NECK', 'JOINT_LEFT_COLLAR',
                        'JOINT_RIGHT_SHOULDER', 'JOINT_RIGHT_ELBOW', 'JOINT_RIGHT_HAND', 
                        'JOINT_LEFT_SHOULDER','JOINT_LEFT_ELBOW', 'JOINT_LEFT_HAND' ]  
        
        list_joint_head, timestamp = self.read_csv_combined(df, action, joints_names[0])
        list_joint_neck, timestamp = self.read_csv_combined(df, action, joints_names[1])
        list_joint_collar, timestamp = self.read_csv_combined(df, action, joints_names[2])
        list_joint_right_shoulder, timestamp = self.read_csv_combined(df, action, joints_names[3])
        list_joint_right_elbow, timestamp = self.read_csv_combined(df, action, joints_names[4])
        list_joint_right_hand, timestamp = self.read_csv_combined(df, action, joints_names[5])
        list_joint_left_shoulder, timestamp = self.read_csv_combined(df, action, joints_names[6])
        list_joint_left_elbow, timestamp = self.read_csv_combined(df, action, joints_names[7])
        list_joint_left_hand, timestamp = self.read_csv_combined(df, action, joints_names[8])
        
        list_joint_head = self.string_to_float(list_joint_head)
        list_joint_neck = self.string_to_float(list_joint_neck)
        list_joint_collar = self.string_to_float(list_joint_collar)
        list_joint_right_shoulder = self.string_to_float(list_joint_right_shoulder)
        list_joint_right_elbow = self.string_to_float(list_joint_right_elbow)
        list_joint_right_hand = self.string_to_float(list_joint_right_hand)
        list_joint_left_shoulder = self.string_to_float(list_joint_left_shoulder)
        list_joint_left_elbow = self.string_to_float(list_joint_left_elbow)
        list_joint_left_hand = self.string_to_float(list_joint_left_hand)
        
        return (list_joint_head, list_joint_neck, list_joint_collar, list_joint_right_shoulder, list_joint_right_elbow, 
           list_joint_right_hand, list_joint_left_shoulder, list_joint_left_elbow, list_joint_left_hand, timestamp)


    def calculate_all_angles(self, df, action):
        '''
        This function calls all subfunctions to calculate all coresponding angles
        '''
        #head_pitch, head_yaw, left_elbow, right_elbow, Left_Shoulder_Pitch, Left_Shoulder_Roll, Right_Shoulder_Pitch, Right_Shoulder_Roll
        target_positions = {'shoulder_right_pitch': [], 'shoulder_right_roll': [],
                                 'shoulder_left_pitch': [], 'shoulder_left_roll': [],
                                 'neck_pitch': [], 'elbow_right': [], 'elbow_left': []}
        head, neck, collar, r_shoulder, r_elbow, r_hand, l_shoulder, l_elbow, l_hand, time = self.get_positions_of_joints(df, action)
        target_positions['neck_pitch'] = self.angle_between_vectors(neck, head, collar)
        target_positions['elbow_left'] = self.angle_between_vectors(l_elbow, l_shoulder, l_hand)
        target_positions['elbow_right'] = self.angle_between_vectors(r_elbow, r_shoulder, r_hand)
        target_positions['shoulder_left_roll'], target_positions['shoulder_left_pitch'] = self.vector_projections(l_hand, l_elbow, l_shoulder)
        target_positions['shoulder_right_roll'], target_positions['shoulder_right_pitch'] = self.vector_projections(r_hand, r_elbow, r_shoulder)
        return target_positions
    